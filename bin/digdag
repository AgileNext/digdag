#!/usr/bin/env ruby

require 'sigdump/setup'

$LOAD_PATH << File.expand_path('../../lib', __FILE__)

file = ARGV[0]
success_tasks_file = ARGV[1]

require 'yaml'
if success_tasks_file
  skip_tasks = YAML.load_file(success_tasks_file) rescue nil
end
skip_tasks ||= {}

require 'digdag/digdag'

loader = Digdag::YamlWorkflowLoader.new
workflow_store = Digdag::WorkflowStore.new
session_store = Digdag::SessionStore.new(workflow_store, Digdag::YamlLiquidRenderer.new)

action_runner = Digdag::ActionRunner.new(Digdag::SessionApi.new(session_store))
queue = Digdag::LocalThreadQueue.new(action_runner)
task_dispatcher = Digdag::TaskDispatcher.new({'default' => queue})

ast = loader.load_file(file)
workflows = ast.map do |name, wf|
  Digdag::WorkflowCompiler.compile(name, wf)
end

wfvs = workflows.map do |workflow|
  workflow_store.create_version(workflow)
end

wfv_ids = wfvs.map {|wfv| wfv.id }
session_ids = session_store.trigger_workflow({now: Time.now.to_s}, wfv_ids, {skip_tasks: skip_tasks})

session_store.start_background_updater(task_dispatcher)
while session_store.any_runnable?
  sleep 0.5
  if success_tasks_file
    File.write(success_tasks_file, YAML.dump(session_store.collect_success_tasks(session_ids)))
  end
end

File.write("graph.dot", session_store.collect_dot_graph)

puts "Data lineage:"
session_store.collect_success_tasks(session_ids).each do |name,data|
  data["inputs"].each do |input|
    puts "  #{input} -> #{name}"
  end
  data["outputs"].each do |output|
    puts "  #{name} -> #{output}"
  end
end



failed = session_store.any_failed?

if failed
  exit 1
else
  if success_tasks_file
    File.delete(success_tasks_file) rescue nil
  end
  exit 0
end

